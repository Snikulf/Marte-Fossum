from tqdm import tqdm
import numpy as np
import matplotlib.pyplot as plt
import sympy as sym
import sys

def q(x,y):
    return 1

def V(x, y):
    return 1

def I(x, y):
    return 1

b = 1
T = 1
Lx = 1
Ly = 1

def first_time_step(b, T, Lx, Ly, dt, f, I, V, q, Nx, Ny):
    
    Nt = int(round(T/dt))
    dx = Lx / Nx
    dy = Ly / Ny
    t = np.linspace(0, T, Nt+1)
    x = np.linspace(0, Lx, Nx+1)
    y = np.linspace(0, Ly, Ny+1)

    u = np.zeros((len(x), len(y)))#, dtype=np.float64)
    u_1 = u.copy()  # = np.zeros(len(u), dtype=np.float64)

    # First time step, inner points

    for i in range(1, Nx-1):
        for j in range(1, Ny-1): 
            u[i,j] = 0.5 * (1/(dt*b/2)) * (dx**2/dt**2 * 
                (0.5*(q(x[i],y[j])+q(x[i+1],y[j])) * (I(x[i+1],y[j])-I(x[i],y[j]))- 
                (0.5*(q(x[i],y[j])+q(x[i-1],y[j])) * (I(x[i],y[j])-I(x[i-1],y[j]))))
                +
                (dy**2/dt**2 * 
                (0.5*(q(x[i],y[j])+q(x[i],y[j+1])) * (I(x[i],y[j+1])-I(x[i],y[j]))- 
                (0.5*(q(x[i],y[j])+q(x[i],y[j-1])) * (I(x[i],y[j])-I(x[i],y[j-1])))))
                +
                dt**2*f(x[i], y[j], t[0]) +
                2*I(x[i],y[j]) + V(x[i],y[j])*dt*(2 - b*dt))

    # Boundary values, du/dn = 0

    # Boundary points at x = 0

    for j in range(1, len(y) - 1):
        u[0,j] = 0.5 * (1/(dt*b/2))* (dx**2/dt**2 * 
        (0.5*(q(x[0],y[j])+q(x[1],y[j])) * (I(x[1],y[j])-I(x[0],y[j]))- 
        (0.5*(q(x[0],y[j])+q(x[1],y[j])) * (I(x[0],y[j])-I(x[1],y[j]))))
        +
        (dy**2/dt**2 * 
        (0.5*(q(x[0],y[j])+q(x[0],y[j+1])) * (I(x[0],y[j+1])-I(x[0],y[j]))- 
        (0.5*(q(x[0],y[j])+q(x[0],y[j-1])) * (I(x[0],y[j])-I(x[0],y[j-1])))))
        +
        dt**2*f(x[0], y[j], t[0]) +
        2*I(x[0],y[j]) + V(x[0],y[j])*dt*(2 - b*dt))   

    # Boundary points at x = Lx

    for j in range(1, len(y) - 1):
        u[-1,j] = 0.5 * (1/(dt*b/2))* (dx**2/dt**2 * 
        (0.5*(q(x[-1],y[j])+q(x[-2],y[j])) * (I(x[-2],y[j])-I(x[-1],y[j]))- 
        (0.5*(q(x[-1],y[j])+q(x[-2],y[j])) * (I(x[-1],y[j])-I(x[-2],y[j]))))
        +
        (dy**2/dt**2 * 
        (0.5*(q(x[-1],y[j])+q(x[-1],y[j+1])) * (I(x[-1],y[j+1])-I(x[-1],y[j]))- 
        (0.5*(q(x[-1],y[j])+q(x[-1],y[j-1])) * (I(x[-1],y[j])-I(x[-1],y[j-1])))))
        +
        dt**2*f(x[-1], y[j], t[0]) +
        2*I(x[-1],y[j]) + V(x[-1],y[j])*dt*(2 - b*dt))   

    # Boundary points at y = 0

    for i in range(1, len(x) - 1):
        u[i,0] = 0.5 * (1/(dt*b/2))* (dx**2/dt**2 * 
        (0.5*(q(x[i],y[0])+q(x[i+1],y[0])) * (I(x[i+1],y[0])-I(x[i],y[0]))- 
        (0.5*(q(x[i],y[0])+q(x[i-1],y[0])) * (I(x[i],y[0])-I(x[i-1],y[0]))))
        +
        (dy**2/dt**2 * 
        (0.5*(q(x[i],y[0])+q(x[i],y[1])) * (I(x[i],y[1])-I(x[i],y[0]))- 
        (0.5*(q(x[i],y[0])+q(x[i],y[0])) * (I(x[i],y[0])-I(x[i],y[1])))))
        +
        dt**2*f(x[i], y[0], t[0]) +
        2*I(x[i],y[0]) + V(x[i],y[0])*dt*(2 - b*dt))   

    # Boundary points at y = Ly

    for i in range(1, len(x) - 1):
        u[i,-1] = 0.5 * (1/(dt*b/2))* (dx**2/dt**2 * 
        (0.5*(q(x[i],y[-1])+q(x[i+1],y[-1])) * (I(x[i+1],y[-1])-I(x[i],y[-1]))- 
        (0.5*(q(x[i],y[-1])+q(x[i-1],y[-1])) * (I(x[i],y[-1])-I(x[i-1],y[-1]))))
        +
        (dy**2/dt**2 * 
        (0.5*(q(x[i],y[-1])+q(x[i],y[-2])) * (I(x[i],y[-2])-I(x[i],y[-1]))- 
        (0.5*(q(x[i],y[-1])+q(x[i],y[-2])) * (I(x[i],y[-1])-I(x[i],y[-2])))))
        +
        dt**2*f(x[i], y[-1], t[0]) +
        2*I(x[i],y[-1]) + V(x[i],y[-1])*dt*(2 - b*dt))  

    # End points, x = 0, y = 0

    u[0,0] = 0.5 * (1/(dt*b/2))* (dx**2/dt**2 * 
    (0.5*(q(x[0],y[0])+q(x[1],y[0])) * (I(x[1],y[0])-I(x[0],y[0]))- 
    (0.5*(q(x[0],y[0])+q(x[1],y[0])) * (I(x[0],y[0])-I(x[1],y[0]))))
    +
    (dy**2/dt**2 * 
    (0.5*(q(x[0],y[0])+q(x[0],y[1])) * (I(x[0],y[1])-I(x[0],y[0]))- 
    (0.5*(q(x[0],y[0])+q(x[0],y[1])) * (I(x[0],y[0])-I(x[0],y[1])))))
    +
    dt**2*f(x[0], y[0], t[0]) +
    2*I(x[0],y[0]) + V(x[0],y[0])*dt*(2 - b*dt))

    # End points, x = 0, y = Ly

    u[0,-1] = 0.5 * (1/(dt*b/2))* (dx**2/dt**2 * 
    (0.5*(q(x[0],y[-1])+q(x[1],y[-1])) * (I(x[1],y[-1])-I(x[0],y[-1]))- 
    (0.5*(q(x[0],y[-1])+q(x[1],y[-1])) * (I(x[0],y[-1])-I(x[1],y[-1]))))
    +
    (dy**2/dt**2 * 
    (0.5*(q(x[0],y[-1])+q(x[0],y[-2])) * (I(x[0],y[-2])-I(x[0],y[-1]))- 
    (0.5*(q(x[0],y[-1])+q(x[0],y[-2])) * (I(x[0],y[-1])-I(x[0],y[-2])))))
    +
    dt**2*f(x[0], y[-1], t[0]) +
    2*I(x[0],y[-1]) - V(x[0],y[-1])*dt*(2 - b*dt))

    # End points, x = Lx, y = 0

    u[-1,0] = 0.5 * (1/(dt*b/2))* (dx**2/dt**2 * 
    (0.5*(q(x[-1],y[0])+q(x[-2],y[0])) * (I(x[-2],y[0])-I(x[-1],y[0]))- 
    (0.5*(q(x[-1],y[0])+q(x[-2],y[0])) * (0(x[-1],y[0])-0(x[-2],y[0]))))
    +
    (dy**2/dt**2 * 
    (0.5*(q(x[-1],y[0])+q(x[-1],y[1])) * (I(x[-1],y[1])-I(x[-1],y[0]))- 
    (0.5*(q(x[-1],y[0])+q(x[-1],y[1])) * (I(x[-1],y[0])-I(x[-1],y[1])))))
    +
    dt**2*f(x[-1], y[0], t[0]) +
    2*I(x[-1],y[0]) - V(x[-1],y[0])*dt*(2 - b*dt))

    # End points, x = Lx, y = Ly

    u[-1,-1] = 0.5 * (1/(dt*b/2))* (dx**2/dt**2 * 
    (0.5*(q(x[-1],y[-1])+q(x[-2],y[-1])) * (I(x[-2],y[-1])-I(x[-1],y[-1]))- 
    (0.5*(q(x[-1],y[-1])+q(x[-2],y[-1])) * (I(x[-1],y[-1])-I(x[-2],y[-1]))))
    +
    (dy**2/dt**2 * 
    (0.5*(q(x[-1],y[-1])+q(x[-1],y[-2])) * (I(x[-1],y[-2])-I(x[-1],y[-1]))- 
    (0.5*(q(x[-1],y[0])+q(x[-1],y[-2])) * (I(x[-1],y[-1])-I(x[-1],y[-2])))))
    +
    dt**2*f(x[-1], y[-1], t[0]) +
    2*I(x[-1],y[-1]) - V(x[-1],y[-1])*dt*(2 - b*dt))

    u_2 = u_1
    u_1 = u

    return u, u_1, u_2, x, y, t 

def fill_points_vectorized(u, u_1, u_2, x, y, t, b, I, V, f, q) # Vectorized version

    dt = t[1] - t[0]
    dx = x[1] - x[0]
    dy = y[1] - y[0]

    for i in range(1, len(t)):

        # Inner points 

        u[1:-1,1:-1] = 0.5*(1/(1 + dt*b/2))*(dt**2/dx**2*(
        (0.5*(q(x[1:-1],y[1:-1])+q(x[2:],y[1:-1])) * (u_1[2:,1:-1]-u_1[1:-1,1:-1]))- 
        (0.5*(q(x[1:-1],y[1:-1])+q(x[0:-2],y[1:-1])) * (u_1[1:-1,1:-1]-u_1[0:-2,1:-1]))) 
        + 
        (dt**2/dy**2*(
        (0.5*(q(x[1:-1],y[1:-1])+q(x[1:-1],y[2:])) * (u_1[1:-1,2:]-u_1[1:-1,1:-1]))- 
        (0.5*(q(x[1:-1],y[1:-1])+q(x[1:-1],y[0:-2])) * (u_1[1:-1,1:-1]-u_1[1:-1,0:-2]))))
        + 
        dt**2*f(x[1:-1], y[1:-1], t[i]) + 2*u_1[1:-1,1:-1] + u_2[1:-1,1:-1]*(dt*b/2 - 1))

        # Boundary points, x = 0

        u[0,1:-1] = 0.5*(1/(1 + dt*b/2))*(dt**2/dx**2*(
        (0.5*(q(x[0],y[1:-1])+q(x[1],y[1:-1])) * (u_1[1,1:-1]-u_1[0,1:-1]))- 
        (0.5*(q(x[0],y[1:-1])+q(x[1],y[1:-1])) * (u_1[0,1:-1]-u_1[1,1:-1]))) 
        + 
        (dt**2/dy**2*(
        (0.5*(q(x[0],y[1:-1])+q(x[0],y[2:])) * (u_1[0,2:]-u_1[0,1:-1]))- 
        (0.5*(q(x[0],y[1:-1])+q(x[0],y[0:-2])) * (u_1[0,1:-1]-u_1[0,0:-2]))))
        + 
        dt**2*f(x[0], y[1:-1], t[i]) + 2*u_1[0,1:-1] + u_2[0,1:-1]*(dt*b/2 - 1))

        # Boundary points, x = Lx

        u[-1,1:-1] = 0.5*(1/(1 + dt*b/2))*(dt**2/dx**2*(
        (0.5*(q(x[-1],y[1:-1])+q(x[-2],y[1:-1])) * (u_1[-2,1:-1]-u_1[-1,1:-1]))- 
        (0.5*(q(x[-1],y[1:-1])+q(x[-2],y[1:-1])) * (u_1[-1,1:-1]-u_1[-2,1:-1]))) 
        + 
        (dt**2/dy**2*(
        (0.5*(q(x[-1],y[1:-1])+q(x[-1],y[2:])) * (u_1[-1,2:]-u_1[-1,1:-1]))- 
        (0.5*(q(x[-1],y[1:-1])+q(x[-1],y[0:-2])) * (u_1[-1,1:-1]-u_1[-1,0:-2]))))
        + 
        dt**2*f(x[-1], y[1:-1], t[i]) + 2*u_1[-1,1:-1] + u_2[-1,1:-1]*(dt*b/2 - 1))

        # Boundary points, y = 0

        u[1:-1,0] = 0.5*(1/(1 + dt*b/2))*(dt**2/dx**2*(
        (0.5*(q(x[1:-1],y[0])+q(x[2:],y[0])) * (u_1[2:,0]-u_1[1:-1,0]))- 
        (0.5*(q(x[1:-1],y[0])+q(x[0:-2],y[0])) * (u_1[1:-1,0]-u_1[0:-2,0]))) 
        + 
        (dt**2/dy**2*(
        (0.5*(q(x[1:-1],y[0])+q(x[1:-1],y[1])) * (u_1[1:-1,1]-u_1[1:-1,0]))- 
        (0.5*(q(x[1:-1],y[0])+q(x[1:-1],y[1])) * (u_1[1:-1,0]-u_1[1:-1,1]))))
        + 
        dt**2*f(x[1:-1], y[0], t[i]) + 2*u_1[1:-1,0] + u_2[1:-1,0]*(dt*b/2 - 1))

        # Boundary points, y = Ly

        u[1:-1,-1] = 0.5*(1/(1 + dt*b/2))*(dt**2/dx**2*(
        (0.5*(q(x[1:-1],y[-1])+q(x[2:],y[-1])) * (u_1[2:,-1]-u_1[1:-1,-1]))- 
        (0.5*(q(x[1:-1],y[-1])+q(x[0:-2],y[-1])) * (u_1[1:-1,-1]-u_1[0:-2,-1]))) 
        + 
        (dt**2/dy**2*(
        (0.5*(q(x[1:-1],y[-1])+q(x[1:-1],y[-2])) * (u_1[1:-1,-2]-u_1[1:-1,-1]))- 
        (0.5*(q(x[1:-1],y[-1])+q(x[1:-1],y[-2])) * (u_1[1:-1,-1]-u_1[1:-1,-2]))))
        + 
        dt**2*f(x[1:-1], y[-1], t[i]) + 2*u_1[1:-1,-1] + u_2[1:-1,-1]*(dt*b/2 - 1))

        # End points, x = 0, y = 0

        u[0,0] = 0.5*(1/(1 + dt*b/2))*(dt**2/dx**2*(
        (0.5*(q(x[0],y[0])+q(x[1],y[0])) * (u_1[1,0]-u_1[0,0]))- 
        (0.5*(q(x[0],y[0])+q(x[1],y[0])) * (u_1[0,0]-u_1[1,0]))) 
        + 
        (dt**2/dy**2*(
        (0.5*(q(x[0],y[0])+q(x[0],y[1])) * (u_1[0,1]-u_1[0,0]))- 
        (0.5*(q(x[0],y[0])+q(x[0],y[1])) * (u_1[0,0]-u_1[0,1]))))
        + 
        dt**2*f(x[0], y[0], t[i]) + 2*u_1[0,0] + u_2[0,0]*(dt*b/2 - 1))

        # End points, x = 0, y = Ly

        u[0,-1] = 0.5*(1/(1 + dt*b/2))*(dt**2/dx**2*(
        (0.5*(q(x[0],y[-1])+q(x[1],y[-1])) * (u_1[1,-1]-u_1[0,-1]))- 
        (0.5*(q(x[0],y[-1])+q(x[1],y[-1])) * (u_1[0,-1]-u_1[1,-1]))) 
        + 
        (dt**2/dy**2*(
        (0.5*(q(x[0],y[-1])+q(x[0],y[-2])) * (u_1[0,-2]-u_1[0,-1]))- 
        (0.5*(q(x[0],y[-1])+q(x[0],y[-2])) * (u_1[0,-1]-u_1[0,-2]))))
        + 
        dt**2*f(x[0], y[-1], t[i]) + 2*u_1[0,-1] + u_2[0,-1]*(dt*b/2 - 1))

        # End points, x = Lx, y = 0

        u[-1,0] = 0.5*(1/(1 + dt*b/2))*(dt**2/dx**2*(
        (0.5*(q(x[-1],y[0])+q(x[-2],y[0])) * (u_1[-2,0]-u_1[-1,0]))- 
        (0.5*(q(x[-1],y[0])+q(x[-2],y[0])) * (u_1[-1,0]-u_1[-2,0]))) 
        + 
        (dt**2/dy**2*(
        (0.5*(q(x[-1],y[0])+q(x[-1],y[1])) * (u_1[-1,1]-u_1[-1,0]))- 
        (0.5*(q(x[-1],y[0])+q(x[-1],y[1])) * (u_1[-1,0]-u_1[-1,1]))))
        + 
        dt**2*f(x[-1], y[0], t[i]) + 2*u_1[-1,0] + u_2[-1,0]*(dt*b/2 - 1))

        # End points, x = Lx, y = Ly

        u[-1,-1] = 0.5*(1/(1 + dt*b/2))*(dt**2/dx**2*(
        (0.5*(q(x[-1],y[-1])+q(x[-2],y[-1])) * (u_1[-2,-1]-u_1[-1,-1]))- 
        (0.5*(q(x[-1],y[-1])+q(x[-2],y[-1])) * (u_1[-1,-1]-u_1[-2,-1]))) 
        + 
        (dt**2/dy**2*(
        (0.5*(q(x[-1],y[-1])+q(x[-1],y[-2])) * (u_1[-1,-2]-u_1[-1,-1]))- 
        (0.5*(q(x[-1],y[-1])+q(x[-1],y[-2])) * (u_1[-1,-1]-u_1[-1,-2]))))
        + 
        dt**2*f(x[-1], y[-1], t[i]) + 2*u_1[-1,-1] + u_2[-1,-1]*(dt*b/2 - 1))

        u_2 = u_1
        u_1 = u

    return u, u_1, u_2

def fill_points_scalar(u, u_1, u_2, x, y, t, b, I, V, f, q) # Scalar version

    dt = t[1] - t[0]
    dx = x[1] - x[0]
    dy = y[1] - y[0]

    for k in range(1, len(t)):
        for i in range(1, Nx-1):
            for j in range(1, Ny-1):
                u[i,j] = 0.5*(1/(1 + dt*b/2))*(dt**2/dx**2*(
                (0.5*(q(x[i],y[j])+q(x[i+1],y[j])) * (u_1[i+1,j]-u_1[i,j]))- 
                (0.5*(q(x[i],y[j])+q(x[i-1],y[j])) * (u_1[i,j]-u_1[i-1,j]))) 
                + 
                (dt**2/dy**2*(
                (0.5*(q(x[i],y[j])+q(x[i],y[j+1])) * (u_1[i,j+1]-u_1[i,j]))- 
                (0.5*(q(x[i],y[j])+q(x[i],y[j-1])) * (u_1[i,j]-u_1[i,j-1]))))
                + 
                dt**2*f(x[i], y[j], t[k]) + 2*u_1[i,j] + u_2[i,j]*(dt*b/2 - 1))

        # Boundary points at x = 0

        for j in range(1, len(y) - 1):
            u[0,j] = 0.5*(1/(1 + dt*b/2))*(dt**2/dx**2*(
            (0.5*(q(x[0],y[j])+q(x[1],y[j])) * (u_1[1,j]-u_1[0,j]))- 
            (0.5*(q(x[0],y[j])+q(x[1],y[j])) * (u_1[0,j]-u_1[1,j]))) 
            + 
            (dt**2/dy**2*(
            (0.5*(q(x[0],y[j])+q(x[0],y[j+1])) * (u_1[0,j+1]-u_1[0,j]))- 
            (0.5*(q(x[0],y[j])+q(x[0],y[j-1])) * (u_1[0,j]-u_1[0,j-1]))))
            + 
            dt**2*f(x[0], y[j], t[k]) + 2*u_1[0,j] + u_2[0,j]*(dt*b/2 - 1))

        # Boundary points at x = Lx

        for j in range(1, len(y) - 1):
            u[-1,j] = 0.5*(1/(1 + dt*b/2))*(dt**2/dx**2*(
            (0.5*(q(x[-1],y[j])+q(x[-2],y[j])) * (u_1[-2,j]-u_1[-1,j]))- 
            (0.5*(q(x[-1],y[j])+q(x[-2],y[j])) * (u_1[-1,j]-u_1[-2,j]))) 
            + 
            (dt**2/dy**2*(
            (0.5*(q(x[-1],y[j])+q(x[-1],y[j+1])) * (u_1[-1,j+1]-u_1[-1,j]))- 
            (0.5*(q(x[-1],y[j])+q(x[-1],y[j-1])) * (u_1[-1,j]-u_1[-1,j-1]))))
            + 
            dt**2*f(x[-1], y[j], t[k]) + 2*u_1[-1,j] + u_2[-1,j]*(dt*b/2 - 1))

        # Boundary points at y = 0

        for i in range(1, len(x) - 1):
            u[i,0] = 0.5*(1/(1 + dt*b/2))*(dt**2/dx**2*(
            (0.5*(q(x[i],y[0])+q(x[i+1],y[0])) * (u_1[i+1,0]-u_1[i,0]))- 
            (0.5*(q(x[i],y[0])+q(x[i-1],y[0])) * (u_1[i,0]-u_1[i-1,0]))) 
            + 
            (dt**2/dy**2*(
            (0.5*(q(x[i],y[0])+q(x[i],y[1])) * (u_1[i,1]-u_1[i,0]))- 
            (0.5*(q(x[i],y[0])+q(x[i],y[1])) * (u_1[i,0]-u_1[i,1]))))
            + 
            dt**2*f(x[i], y[0], t[k]) + 2*u_1[i,0] + u_2[i,0]*(dt*b/2 - 1))

        # Boundary points at y = Ly

        for i in range(1, len(x) - 1):
            u[i,-1] = 0.5*(1/(1 + dt*b/2))*(dt**2/dx**2*(
            (0.5*(q(x[i],y[-1])+q(x[i+1],y[-1])) * (u_1[i+1,-1]-u_1[i,-1]))- 
            (0.5*(q(x[i],y[-1])+q(x[i-1],y[-1])) * (u_1[i,-1]-u_1[i-1,-1]))) 
            + 
            (dt**2/dy**2*(
            (0.5*(q(x[i],y[-1])+q(x[i],y[-2])) * (u_1[i,-2]-u_1[i,-1]))- 
            (0.5*(q(x[i],y[-1])+q(x[i],y[-2])) * (u_1[i,-1]-u_1[i,-2]))))
            + 
            dt**2*f(x[i], y[-1], t[k]) + 2*u_1[i,-1] + u_2[i,-1]*(dt*b/2 - 1))        

        # End points at x = 0, y = 0

        u[0,0] = 0.5*(1/(1 + dt*b/2))*(dt**2/dx**2*(
            (0.5*(q(x[0],y[0])+q(x[1],y[0])) * (u_1[1,0]-u_1[0,0]))- 
            (0.5*(q(x[0],y[0])+q(x[1],y[0])) * (u_1[0,0]-u_1[1,0]))) 
            + 
            (dt**2/dy**2*(
            (0.5*(q(x[0],y[0])+q(x[0],y[1])) * (u_1[0,1]-u_1[0,0]))- 
            (0.5*(q(x[0],y[0])+q(x[0],y[1])) * (u_1[0,0]-u_1[0,1]))))
            + 
            dt**2*f(x[0], y[0], t[k]) + 2*u_1[0,0] + u_2[0,0]*(dt*b/2 - 1))

        # End points at x = 0, y = Ly

        u[0,-1] = 0.5*(1/(1 + dt*b/2))*(dt**2/dx**2*(
            (0.5*(q(x[0],y[-1])+q(x[1],y[-1])) * (u_1[1,-1]-u_1[0,-1]))- 
            (0.5*(q(x[0],y[-1])+q(x[1],y[-1])) * (u_1[0,-1]-u_1[1,-1]))) 
            + 
            (dt**2/dy**2*(
            (0.5*(q(x[0],y[-1])+q(x[0],y[-2])) * (u_1[0,-2]-u_1[0,-1]))- 
            (0.5*(q(x[0],y[-1])+q(x[0],y[-2])) * (u_1[0,-1]-u_1[0,-2]))))
            + 
            dt**2*f(x[0], y[-1], t[k]) + 2*u_1[0,-1] + u_2[0,-1]*(dt*b/2 - 1))

        # End points at x = Lx, y = 0

        u[-1,0] = 0.5*(1/(1 + dt*b/2))*(dt**2/dx**2*(
            (0.5*(q(x[-1],y[0])+q(x[-2],y[0])) * (u_1[-2,0]-u_1[-1,0]))- 
            (0.5*(q(x[-1],y[0])+q(x[-2],y[0])) * (u_1[-1,0]-u_1[-2,0]))) 
            + 
            (dt**2/dy**2*(
            (0.5*(q(x[-1],y[0])+q(x[-1],y[1])) * (u_1[-1,1]-u_1[-1,0]))- 
            (0.5*(q(x[-1],y[0])+q(x[-1],y[1])) * (u_1[-1,0]-u_1[-1,1]))))
            + 
            dt**2*f(x[-1], y[0], t[k]) + 2*u_1[-1,0] + u_2[-1,0]*(dt*b/2 - 1))

        # End points at x = Lx, y = Ly

        u[-1,-1] = 0.5*(1/(1 + dt*b/2))*(dt**2/dx**2*(
            (0.5*(q(x[-1],y[-1])+q(x[-2],y[-1])) * (u_1[-2,-1]-u_1[-1,-1]))- 
            (0.5*(q(x[-1],y[-1])+q(x[-2],y[-1])) * (u_1[-1,-1]-u_1[-2,-1]))) 
            + 
            (dt**2/dy**2*(
            (0.5*(q(x[-1],y[-1])+q(x[-1],y[-2])) * (u_1[-1,-2]-u_1[-1,-1]))- 
            (0.5*(q(x[-1],y[-1])+q(x[-1],y[-2])) * (u_1[-1,-1]-u_1[-1,-2]))))
            + 
            dt**2*f(x[-1], y[-1], t[k]) + 2*u_1[-1,-1] + u_2[-1,-1]*(dt*b/2 - 1))

    return u, u_1, u_2





